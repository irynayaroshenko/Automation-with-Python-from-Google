"""Intermittently Failing Script"""
# Bug with company's internal reminder app described: users could send reminder on Jan,7 but failed on Jan,13.
# Why could the application work fine for January 7th but fail for January 13th?
# There could be a bunch of reasons. But in general, when dates are involved in a failure, the problem is due to how
# the dates are formatted.
# In some countries, the dates are written with the month first and the day second, while in other countries vise versa.

# To figure out what's going on, add more debugging information to the program.

# open reminder_script.png

# We see that this script is calling a program called 'zenity'. Zenity is the application showing the window to select
# the date, title, and emails.
# The output generated by Zenity is stored in a variable called meeting_info, which is then passed as a parameter to the
# send_reminders.py, python3 script. This script then sends the emails.
# To get more info about the output generated by Zenity, we'd like to see the value of the meeting_info variable before
# the Python script gets called. Let's add an 'echo' statement to see that.

# Add 'echo $meeting_info' to script. Open reminder_script_echo.png

# Test result:
# 01/13/2020|Test|amanda
# Open reminder_script_echo_output.png

# We see that the information generated by Zenity is split by pipes, and that the data is formatted as month/day/year.
# That's already valuable information. Now, the next step is getting a more informative error.
# To do that, let's open the Python script that sends the reminders, and see if we can make it print a better error.

# open send_reminders_script_1.png, send_reminders_script_2.png, send_reminders_script_3.png

# The file is long, so it makes sense to start by looking at the main() function that lists the core functionality of
# the program.
# We see that it splits the parameter receive in three, then prepares the message to be sent, and finally sends it.
# If everything works fine, it prints a message saying that it was sent successfully.
# But if anything fails, it prints the error message that we've seen already.
# But the error message is not very useful, as it's hiding the reasons why things failed.
# Let's make this error more helpful by also printing the exception that generated the failure.

# open send_reminders_script_4.png

# retest after edding to print error: open send_reminders_script_5.png

# This time we see that the problem is that the date format we are using is putting the month first, but the program is
# expecting to have the month second. As there's no month 13, this is an invalid date.
# So we found the root cause of the problem: program is trying to convert the date assuming one specific date format,
# but we're using a different format.

# As we now know, once we know the root cause, the next step is to remediate the issue.
# What can we do in this case to remediate the problem?

# We could change the program to use our date format, but then the application would break for people running it in a
# different location.
# What we need to do is make sure that no matter where we run the script, the date generated by Zenity matches the date
# expected by Python.
# Fortunately, Zenity includes a parameter to specify any format we want.

# So we'll change the shell script to use the --forms-date-format='%Y-%m-%d' to set the format which is the
# international standard date format. With that, Zenity will return the date in the international format.
# open meeting_reminder_fix.png  (also we need to delete debugging 'echo' line there)

# Now, we need to change the Python script to use the same format.
# We'll go to the function that has the format specified and change it to the same format.
# open send_reminders_script_6.png  (also we need to delete debugging printing error line there)

# Now, the date format generated by Zenity should always match the one read by Python.
# This script should work in our country and any others.


"""Tasks from quiz"""
# The compare_strings function is supposed to compare just the alphanumeric content of two strings, ignoring upper vs
# lower case and punctuation. But something is not working.
# Fill in the code to try to find the problems, then fix the problems.

import re


def compare_strings(string1, string2):
    # Convert both strings to lowercase and remove leading and trailing blanks
    string1 = string1.lower().strip()
    string2 = string2.lower().strip()

    # Ignore punctuation
    punctuation = r"[.?!,;:\-']"  # my solution to screen '-' sign
    string1 = re.sub(punctuation, r"", string1)
    string2 = re.sub(punctuation, r"", string2)

    # DEBUG CODE GOES HERE
    print('___')

    return string1 == string2


print(compare_strings("Have a Great Day!", "Have a great day?"))  # True
print(compare_strings("It's raining again.", "its raining, again"))  # True
print(compare_strings("Learn to count: 1, 2, 3.", "Learn to count: one, two, three."))  # False
print(compare_strings("They found some body.", "They found somebody."))  # False

# Other solutions:
# https://brainly.com/question/17142922
# https://quizlet.com/554629908/coursera-practice-quiz-understanding-the-problem-flash-cards/


# The datetime module supplies classes for manipulating dates and times, and contains many types, objects, and methods.
# You've seen some of them used in the 'dow' function, which returns the day of the week for a specific date. We'll use
# them again in the next_date function, which takes the date_string parameter in the format of "year-month-day", and
# uses the add_year function to calculate the next year that this date will occur (it's 4 years later for the 29th of
# February during Leap Year, and 1 year later for all other dates). Then it returns the value in the same format as it
# receives the date: "year-month-day".
# Can you find the error in the code? Is it in the next_date function or the add_year function? How can you determine
# if the add_year function returns what it's supposed to? Add debug lines as necessary to find the problems, then fix
# the code to work as indicated above.

import datetime
from datetime import date


def add_year(date_obj):
    try:
        new_date_obj = date_obj.replace(year=date_obj.year + 1)
    except ValueError:
        # This gets executed when the above method fails,
        # which means that we're making a Leap Year calculation
        new_date_obj = date_obj.replace(year=date_obj.year + 4)
    return new_date_obj


def next_date(date_string):
    # Convert the argument from string to date object
    date_obj = datetime.datetime.strptime(date_string, r"%Y-%m-%d")
    next_date_obj = add_year(date_obj)

    # Convert the datetime object to string,
    # in the format of "yyyy-mm-dd"
    next_date_string = next_date_obj.strftime("yyyy-mm-dd")  # Should be strftime("%Y-%m-%d")
    return next_date_string


today = date.today()  # Get today's date
print(next_date(str(today)))
# Should return a year from today, unless today is Leap Day

print(next_date("2021-01-01"))  # Should return 2022-01-01
print(next_date("2020-02-29"))  # Should return 2024-02-29

# more info about this task:
# https://github.com/elmoallistair/google-it-automation/blob/master/c4_troubleshooting-debugging-techniques/1_troubleshooting-concepts/practice-quiz-understanding-the-problem.md