"""Understanding Crashing Applications"""
# When an application crashes, and we don't know why we'll want to look for
# logs that might relate to the failure.

# To look at logs on:

# Linux - system log files in /var/log/ (e.g., /var/log/sys) or  User log files in .accession errors file.
# Open var_log_Linux.png

# MacOS
# use 'Console app'

# Windows
# 'Windows Event Viewer'

# First you should look for date and time (for each line logged). Knowing when the application crashed you can look for
# a log line around that time. And try to find an error message related to the application that crashed.
# Sometimes the errors will be self-explanatory: 'Permission denied', 'no such file or directory', 'connection refused'.
# Sometimes it will be a cryptic message, and you have no idea what it means.

# Whenever we have an error message no matter how weird it seems we can search for it online to try to figure out its
# meaning. If we're lucky, we might find official documentation of what that error means and what we can do about it.
# But even if that's not available, we'll usually come across posts by others who have tackled a similar error and
# this additional information can help us understand what's going on.

# If there are no errors or the errors aren't useful we can try to find out more info by enabling 'Debug logging'.
# Many applications generate a lot more output when debugging logging is enabled.
# We might need to enable it from a setting in the applications configuration file or
# a command line parameter to pass when running the application manually.
# By enabling this extra logging information, we can get a better idea of what's actually causing the problem.

# What to do if there are no logs or error messages at all? Use tools which show what going on inside the program.
# We call that a few already:
# Linux - 'strace' to see what system calls a programs doing.
# MacOS - 'dtruss'
# Windows  - 'Process Monitor' - takes a peek inside what's going on inside a process on Windows

# By tracing, which system calls a program is doing, we can see what files and
# directories it's trying open, what network connections it's trying to make, and
# what information it's trying to read or write.

# We could find that the problem is caused by a resource not being present that the program expects to be present.
# Like we saw with the missing directory example in the earlier module, or we could find that the program tries to
# interact with the graphics interface and there isn't any because it's a service running on a server.
# Or the program tries to open a file but the user running the software doesn't have the necessary permissions.

# If the application used to work fine and recently started crashing, it's useful to look into what changed in between.

# The first thing is to check if the issue is caused by a new version of the application itself.
# Maybe there's a bug in the new version that causes the crash or maybe the way that we're using the application is no
# longer supported. But that's not the only possible change that could trigger crashes.

# It could also be that a library or service used by our application changed and they no longer work well together, or
# it could be that there was a configuration change in the overall environment. Like if the user isn't in a specific
# group anymore or if the files that the application used are in a different location.

# When trying to figure out what changed logs can also be a useful source of information.
# In the system log we can check which programs and libraries were recently updated. Checking for configuration changes
# might be harder depending on how you manage that configuration.
# If the settings are managed through a configuration management system and the values are stored in a VCS, then you
# might be able to look at the history of changes and figure out which one triggered the failure.

# We call that a few times already how important it is to have a reproduction case for a problem that we're trying to
# solve. When we're trying to debug an application that crashes, finding a reproduction case can help us both understand
# what's causing the crash and figure out what we can do to fix it.

# This includes:
# - the overall system environment,
# - the specific application configuration,
# - the inputs to the application,
# - the outputs generated by the application,
# - the resources that uses,
# - the services it communicates with.

# When trying to recreate the reproduction case it might be useful to start from a clean slate and slowly put the pieces
# in place until the crash triggers. This might include trying out the application with the default configuration
# instead of the local one or on a freshly installed computer instead of the computer where it's crashing.

# And remember we want to make the reproduction case as small as possible: this lets us better understand the problem
# and also quickly check if it's present or not when we attempt to fix it.
# And even if we end up unable to fix the issue, having a small and simple reproduction case is extremely helpful in
# reporting a bug to the program's developers.

# So to sum this up to find the root cause of a crashing application we want:
# - look at all available logs,
# - figure out what changed,
# - trace the system or library calls the program makes,
# - create the smallest possible reproduction case.

"""What to do when you can't fix the program?"""
# No matter the reason, what can you do if you need to fix an application that crashes, and you can't change the code?
# You'll need to figure out a way of working around the problem and avoiding the crash.
# The actual workaround will depend on what the issue is that you're trying to solve.

# Say you figured out that the issue was caused by a specific data input that makes the application crash.
# The crashes only happen when the input isn't in the format the code expects. Some of your systems generate data in
# XML format which used to work fine with the previous version of the software but the new version now requires
# all data to be in a YAML format.

# In this case you can write a script that pre-processes the data and make sure that it's in the format that the program
# expects.

# Similarly, if the problem is caused by an external service that the application uses and that's no longer compatible,
# we could write a service to act as a proxy and make sure that both sides see the requests and responses they expect.
# This type of compatibility layer is called a Wrapper.

# 'Wrapper' is a function or program that provides a compatibility layer between two functions or programs, so they can
# work well together.

# Using Wrappers is a pretty common technique when the expected output and input formats don't match.
# So if you're faced with some sort of compatibility problem don't be afraid to write a Wrapper to work around it.

# Another possibility you might need to look at is if the overall system environment isn't working well with the
# application. In this case, you might want to check what environment the applications developers recommend
# and then modify your systems to match that. This could be running the same version of OS, using the same version
# of the dynamic libraries or interacting with the same back-end services.

# Say the application was developed and tested on Windows 7, if you run into problems while trying to run it under
# Windows 10, you might want to use Windows 7 instead or if the application was developed and tested for Ubuntu and
# you're having trouble running it under Fedora, you might want to try running it on Ubuntu instead.

# What can you do if you can't make the environment match?

# This could happen, for example, if there's another application that requires a different version of the same library,
# or you can't change a certain configuration setting because it's required to access a different service.

# In this case, you might want to consider running the application inside a Virtual machine or maybe a Container.
# They both let you run the affected application in its own environment without interfering with the rest of the system.
# This is what we need if we want the environment to be different from the one other Applications
# are using on the same computer.

# Sometimes we can't find a way to stop an application from crashing, but we can make sure that if it crashes it starts
# back again. To do this, we can deploy a 'watchdog'. This is a process that checks whether a program is running and
# when it's not, starts the program again.

# To implement this, we need to write a script that stays running in the background and periodically checks
# if the other program is running. Whenever the check fails the watchdog will trigger the program to restart.
# Doing this won't avoid the crash itself. But it will at least ensure that the service is available.
# This works well for services where availability matters more than running continuously.
#
# No matter how you work around the issue, remember to always report the bug to the application developers.
# As we called out, if you have a good reproduction case for your issue, it makes it easier for the developers to
# figure out what's wrong and how to fix it.

# So when you report a bug make sure you include as much information as possible, share good reproduction case and
# answer the questions that we mentioned earlier on.

