"""Pipes and Pipelines"""
# Another powerful way to perform IO stream redirection called Piping.
# Using pipes, you can connect multiple scripts, commands, or other programs together into a data processing pipeline.
# Pipes connect the output of one program to the input of another.
# This means we can pass data between programs, taking the output of one and making it the input of the next.
# Pipes are represented by '|' (pipe char). Using pipes allows to create new commands by combining the functionality
# of one command, with the functionality of another without having to store the contents in an intermediate file.

# ls -l | less

# Output of the 'ls-l' command is connected to the input of the 'less' command, which is a terminal paging program.
# It's useful when you want to look at the contents of a directory containing lots of files.
# The list of files generated by 'ls' is piped to 'less', which displays them one page at a time.
# Scroll up or down using the page up, page down, or arrow keys and quit with Q.

# Other example (open screenshot cat_pipes_command.png):

# cat spider.txt | tr ' ' '\n' | sort | uniq -c | sort -nr | head

# result:
# 7 the
# 3 tuple3 spider
# 3 and
# 2 rain
# 2 itsy
# 2 climbed
# 2 came
# 2 bitsy
# 1 waterspout.

# explanation:
# 'cat' to get the contents of spider.txt.
# Those contents are then sent to a command called 'tr' ('translate'). It takes the characters in the first parameter,
# in this case, it's a space and then transform them into a character in the second parameter - \n.
# Basically, we're putting each word in its own separate line.
# Next, we pass results to the 'sort' command through a pipe (sorts results alphabetically).
# The sorted results are then passed to the 'unique' command, which displays each match once, and by using '-c' flag,
# it prefixes each unique line with a number of times it occurred.
# This output is passed via pipe to the 'sort' command once more, this time, with the '-nr' flag, which sorts results
# numerically and in reverse order, from most to least hits.
# The output is finally passed to the 'head' command, which prints the first 10 lines to stdl.


# You can use your Python scripts and pipelines too.
# Python can read from standard input using the stdin file object provided by the sys module.

# Example (open screenshot pipes_script.png):
# write a script that reads each line of the input and then prints a line with the first character in uppercase.
# To do this, we'll take advantage of the capitalize string method.
# create file capitalize.py with code:
import sys


for line in sys.stdin:
    print(line.strip().capitalize())

# create file haiku.txt with text:
# advance your career,
# automating with Python,
# it's so fun to learn.

# Use a pipeline to capitalize our haiku by combining the output of 'cat' command with capitalized script:
# cat haiku.txt | ./capitalize.py

# Open screenshot haiku_capitalize_result.png
# 'cat' sends the contents of haiku.txt file to standard output, which we redirect to our script using a pipe.
# Our capitalized script uses the sys stdin file object to iterate through each line of standard input,
# printing the capitalized version to standard output.

# Result:
# Advance your career,
# Automating with Python,
# It's so fun to learn.

# The same result we get with command: ./capitalize.py < haiku.txt

# As a rule, if you just need to get something from standard input into your script, using a redirection is enough.
# But if you want this to be part of a bigger pipeline of commands, you'll need to combine them with pipes.
# For example, if we only want to capitalize the lines that match a certain pattern, we could first call 'grep' and then
# connect it with the pipe to our scripts.
