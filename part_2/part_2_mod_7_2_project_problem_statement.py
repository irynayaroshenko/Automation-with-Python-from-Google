"""Project Problem Statement"""
# Imagine a scenario: one of the servers used by your company runs a service called 'ticky'.
# This service is an internal ticketing system used by a lot of different teams in the company to manage their work.
# The service logs a bunch of events to syslog, both when it runs successfully and when it encounters errors.

# Developers of the service are asking for your help with getting some information out of those logs, to better
# understand how the software is being used and how to improve it.

# As final project in this course, you'll write some automation scripts that will process the system log and generate
# a bunch of reports based on the information extracted from log files.
# Log lines example:

# May 27 11:45:40 ubuntu.local ticky: INFO: Created ticket [#1234] (username)
# Jun  1 11:06:48 ubuntu.local ticky: ERROR: Connection to DB failed (username)

# When the service runs correctly, it logs an INFO message to syslog, stating what it's done, the username, and the
# ticket number related to the event.

# If the service encounters a problem, it logs in error message to the syslog, indicating what was wrong and the
# username that triggered the action that caused the problem.

# The developers of the service want 2 different reports out of this data.

# The first one is a ranking of errors generated by the system.
# This means a list of all error messages logged, and how many times each of them was found, not taking into account
# the users involved.
# They should be sorted by the most common error to the least common error.

# The second one is a usage statistics for the service.
# This means, a list of all users that have used the system including how many info messages and how many error messages
# they've generated.
# This report should be sorted by username.

# To visualize the data in these reports, you want to generate a couple of webpages that'll be served by a web server
# running on the machine.
# To do this, you can make use of a script that's already in the system called csv_ to_html.py.
# This script converts the data in a CSV file into an HTML file containing a table with the data.

# Then, put the files in the directory that's used by the webserver to display the webpages.

# The goal is to have one script that can get all the necessary work done automatically, every day without any user
# interaction.

# This script doesn't need to do all the work itself. It can call on other scripts to do individual task and then put
# the results together. We recommend splitting the task so that each piece can be written and tested separately.

"""Help with Research and Planning"""
# We've said that we want to find some specific log lines in the syslog file.
# We strongly recommend that you use regular expressions to find them.

# To figure out the right regular expression, you can use a website like regex101.com
# which can help you test your expression and understand what's going on with it.
# Once you have a pattern that you think and work, try it out in a Python interpreter to verify that it
# matches the right lines and captures the right information.

# After extracting the information, you'll need to count how many errors are of the same type, and how many info and
# error messages there are for a given user.
# Dictionaries might help. You'll want to use a couple of different dictionaries.
# One to account error messages and another to count per user usage.

# You'll then need to sort the data in a dictionary's by different criteria (dict.sort()).

# The output of your Python script should be a couple of CSV files.
# Each of them containing the names of the columns and the data in the order that it needs to be presented.

# Once those files are generated, you'll need to call csv_to_html.py script to create HTML files based on CSV data.
# You'll have access to look at how the script works but the key is to pass two parameters to it.
# The name of the CSV file to read and the name of the HTML file to generate.
# You could do this last step from either a Python script or a bash script.
# Since the script will be only calling commands and moving files, we recommend doing a bash.
